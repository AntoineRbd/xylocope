#!/usr/bin/env node

/**
 * üß™ Script de test pour le d√©ploiement Xylocope
 * 
 * Ce script v√©rifie que tous les pr√©requis sont en place
 * et teste la connectivit√© avant le d√©ploiement
 * 
 * Usage: node scripts/test-deployment.js
 */

const https = require('https');
const http = require('http');
const fs = require('fs');
const path = require('path');

// Configuration
const CONFIG = {
    site: {
        url: 'https://xylocope.fr',
        expectedFiles: [
            '/',
            '/css/main.css',
            '/js/main.js',
            '/assets/icons/logoV2.png'
        ]
    },
    local: {
        requiredFiles: [
            'index.html',
            'css/main.css',
            'js/main.js',
            'package.json',
            '.github/workflows/deploy.yml'
        ],
        requiredDirs: [
            'css',
            'js',
            'images',
            'assets'
        ]
    }
};

/**
 * Couleurs pour les logs
 */
const colors = {
    reset: '\x1b[0m',
    red: '\x1b[31m',
    green: '\x1b[32m',
    yellow: '\x1b[33m',
    blue: '\x1b[34m',
    magenta: '\x1b[35m',
    cyan: '\x1b[36m'
};

/**
 * Logger avec couleurs
 */
const log = {
    info: (msg) => console.log(`${colors.blue}‚ÑπÔ∏è  ${msg}${colors.reset}`),
    success: (msg) => console.log(`${colors.green}‚úÖ ${msg}${colors.reset}`),
    warning: (msg) => console.log(`${colors.yellow}‚ö†Ô∏è  ${msg}${colors.reset}`),
    error: (msg) => console.log(`${colors.red}‚ùå ${msg}${colors.reset}`),
    title: (msg) => console.log(`\n${colors.cyan}üîç ${msg}${colors.reset}\n`),
    separator: () => console.log(`${colors.magenta}${'='.repeat(60)}${colors.reset}`)
};

/**
 * V√©rifier l'existence d'un fichier
 */
function checkFile(filePath) {
    try {
        const stats = fs.statSync(filePath);
        return { exists: true, size: stats.size, isFile: stats.isFile() };
    } catch (error) {
        return { exists: false, error: error.message };
    }
}

/**
 * V√©rifier l'existence d'un dossier
 */
function checkDirectory(dirPath) {
    try {
        const stats = fs.statSync(dirPath);
        return { exists: true, isDirectory: stats.isDirectory() };
    } catch (error) {
        return { exists: false, error: error.message };
    }
}

/**
 * Faire une requ√™te HTTP(S)
 */
function makeRequest(url, timeout = 10000) {
    return new Promise((resolve, reject) => {
        const urlObj = new URL(url);
        const client = urlObj.protocol === 'https:' ? https : http;
        
        const req = client.get(url, {
            timeout,
            headers: {
                'User-Agent': 'Xylocope-Deployment-Test/1.0'
            }
        }, (res) => {
            let data = '';
            
            res.on('data', chunk => data += chunk);
            res.on('end', () => {
                resolve({
                    statusCode: res.statusCode,
                    headers: res.headers,
                    data: data,
                    url: url
                });
            });
        });
        
        req.on('error', reject);
        req.on('timeout', () => {
            req.destroy();
            reject(new Error(`Timeout apr√®s ${timeout}ms`));
        });
    });
}

/**
 * Tester la structure locale du projet
 */
async function testLocalStructure() {
    log.title('Test de la structure locale');
    
    let errors = 0;
    
    // V√©rifier les fichiers requis
    log.info('V√©rification des fichiers requis...');
    for (const file of CONFIG.local.requiredFiles) {
        const result = checkFile(file);
        if (result.exists && result.isFile) {
            log.success(`${file} (${Math.round(result.size / 1024)}KB)`);
        } else {
            log.error(`${file} - ${result.error || 'Non trouv√©'}`);
            errors++;
        }
    }
    
    // V√©rifier les dossiers requis
    log.info('\nV√©rification des dossiers requis...');
    for (const dir of CONFIG.local.requiredDirs) {
        const result = checkDirectory(dir);
        if (result.exists && result.isDirectory) {
            const files = fs.readdirSync(dir);
            log.success(`${dir}/ (${files.length} fichiers)`);
        } else {
            log.error(`${dir}/ - ${result.error || 'Non trouv√©'}`);
            errors++;
        }
    }
    
    // V√©rifier le package.json
    log.info('\nV√©rification du package.json...');
    try {
        const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
        
        if (packageJson.scripts && packageJson.scripts.build) {
            log.success('Script de build pr√©sent');
        } else {
            log.warning('Script de build manquant');
        }
        
        if (packageJson.scripts && packageJson.scripts.test) {
            log.success('Script de test pr√©sent');
        } else {
            log.warning('Script de test manquant');
        }
        
        if (packageJson.devDependencies) {
            const depCount = Object.keys(packageJson.devDependencies).length;
            log.success(`${depCount} d√©pendances de d√©veloppement`);
        }
        
    } catch (error) {
        log.error(`Erreur lors de la lecture du package.json: ${error.message}`);
        errors++;
    }
    
    return errors === 0;
}

/**
 * Tester la configuration GitHub Actions
 */
async function testGitHubActions() {
    log.title('Test de la configuration GitHub Actions');
    
    const workflowFile = '.github/workflows/deploy.yml';
    const result = checkFile(workflowFile);
    
    if (!result.exists) {
        log.error('Fichier workflow GitHub Actions non trouv√©');
        return false;
    }
    
    log.success(`Workflow trouv√© (${Math.round(result.size / 1024)}KB)`);
    
    try {
        const workflowContent = fs.readFileSync(workflowFile, 'utf8');
        
        // V√©rifications basiques du contenu
        const checks = [
            { pattern: /on:\s*push:/, message: 'D√©clenchement sur push configur√©' },
            { pattern: /branches:\s*\[\s*main\s*\]/, message: 'Branche main configur√©e' },
            { pattern: /FTP_USERNAME/, message: 'Variable FTP_USERNAME utilis√©e' },
            { pattern: /FTP_PASSWORD/, message: 'Variable FTP_PASSWORD utilis√©e' },
            { pattern: /SamKirkland\/FTP-Deploy-Action/, message: 'Action FTP Deploy configur√©e' },
            { pattern: /npm run build/, message: 'Build step pr√©sent' },
            { pattern: /npm run test/, message: 'Test step pr√©sent' }
        ];
        
        for (const check of checks) {
            if (check.pattern.test(workflowContent)) {
                log.success(check.message);
            } else {
                log.warning(check.message + ' - NON TROUV√â');
            }
        }
        
        return true;
    } catch (error) {
        log.error(`Erreur lors de la lecture du workflow: ${error.message}`);
        return false;
    }
}

/**
 * Tester l'acc√®s au site web
 */
async function testWebsiteAccess() {
    log.title('Test d\'acc√®s au site web');
    
    let totalErrors = 0;
    
    for (const path of CONFIG.site.expectedFiles) {
        const url = CONFIG.site.url + path;
        
        try {
            log.info(`Test: ${url}`);
            const response = await makeRequest(url, 15000);
            
            if (response.statusCode === 200) {
                const sizeKB = Math.round(response.data.length / 1024);
                log.success(`OK (${response.statusCode}) - ${sizeKB}KB`);
                
                // V√©rifications sp√©cifiques
                if (path === '/') {
                    if (response.data.includes('<title>')) {
                        log.success('  ‚Üí Titre HTML trouv√©');
                    } else {
                        log.warning('  ‚Üí Titre HTML non trouv√©');
                    }
                    
                    if (response.data.includes('Xylocope')) {
                        log.success('  ‚Üí Contenu Xylocope d√©tect√©');
                    } else {
                        log.warning('  ‚Üí Contenu Xylocope non d√©tect√©');
                    }
                }
                
                if (path.endsWith('.css')) {
                    if (response.data.includes('color') || response.data.includes('background')) {
                        log.success('  ‚Üí CSS valide d√©tect√©');
                    } else {
                        log.warning('  ‚Üí CSS pourrait √™tre invalide');
                    }
                }
                
                if (path.endsWith('.js')) {
                    if (response.data.includes('function') || response.data.includes('class') || response.data.includes('=>')) {
                        log.success('  ‚Üí JavaScript valide d√©tect√©');
                    } else {
                        log.warning('  ‚Üí JavaScript pourrait √™tre invalide');
                    }
                }
                
            } else {
                log.error(`ERREUR (${response.statusCode})`);
                totalErrors++;
            }
            
        } catch (error) {
            log.error(`√âCHEC: ${error.message}`);
            totalErrors++;
        }
    }
    
    return totalErrors === 0;
}

/**
 * Tester les en-t√™tes de s√©curit√©
 */
async function testSecurityHeaders() {
    log.title('Test des en-t√™tes de s√©curit√©');
    
    try {
        const response = await makeRequest(CONFIG.site.url);
        const headers = response.headers;
        
        // V√©rifications des en-t√™tes de s√©curit√©
        const securityChecks = [
            { header: 'x-content-type-options', expected: 'nosniff', message: 'X-Content-Type-Options' },
            { header: 'x-frame-options', expected: 'SAMEORIGIN', message: 'X-Frame-Options' },
            { header: 'strict-transport-security', expected: null, message: 'HSTS (Strict-Transport-Security)' }
        ];
        
        for (const check of securityChecks) {
            const headerValue = headers[check.header];
            if (headerValue) {
                if (check.expected && headerValue.toLowerCase().includes(check.expected.toLowerCase())) {
                    log.success(`${check.message}: ${headerValue}`);
                } else if (!check.expected) {
                    log.success(`${check.message}: ${headerValue}`);
                } else {
                    log.warning(`${check.message}: ${headerValue} (attendu: ${check.expected})`);
                }
            } else {
                log.warning(`${check.message}: Non configur√©`);
            }
        }
        
        // V√©rifier HTTPS
        if (response.url.startsWith('https://')) {
            log.success('HTTPS activ√©');
        } else {
            log.error('HTTPS non activ√©');
            return false;
        }
        
        return true;
    } catch (error) {
        log.error(`Erreur lors du test de s√©curit√©: ${error.message}`);
        return false;
    }
}

/**
 * Rapport final
 */
function generateReport(results) {
    log.separator();
    log.title('üìä RAPPORT FINAL');
    
    const passed = results.filter(r => r.passed).length;
    const total = results.length;
    
    console.log(`Tests r√©ussis: ${passed}/${total}\n`);
    
    for (const result of results) {
        if (result.passed) {
            log.success(`${result.name}: R√âUSSI`);
        } else {
            log.error(`${result.name}: √âCHEC`);
        }
    }
    
    console.log();
    
    if (passed === total) {
        log.success('üéâ Tous les tests sont pass√©s ! Le d√©ploiement devrait fonctionner correctement.');
        return true;
    } else {
        log.error('‚ùå Certains tests ont √©chou√©. V√©rifiez la configuration avant de d√©ployer.');
        return false;
    }
}

/**
 * Fonction principale
 */
async function main() {
    console.log(`
${colors.cyan}
 ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó      ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù
‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  
‚ñà‚ñà‚ïë‚ñÑ‚ñÑ ‚ñà‚ñà‚ïë  ‚ïö‚ñà‚ñà‚ïî‚ïù  ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  
‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
 ‚ïö‚ïê‚ïê‚ñÄ‚ñÄ‚ïê‚ïù    ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
                                                                     
üß™ Test de D√©ploiement - Version 1.0.0
${colors.reset}
    `);
    
    const results = [];
    
    try {
        // Test 1: Structure locale
        const localTest = await testLocalStructure();
        results.push({ name: 'Structure locale', passed: localTest });
        
        // Test 2: GitHub Actions
        const ghActionsTest = await testGitHubActions();
        results.push({ name: 'Configuration GitHub Actions', passed: ghActionsTest });
        
        // Test 3: Acc√®s web
        const webTest = await testWebsiteAccess();
        results.push({ name: 'Acc√®s au site web', passed: webTest });
        
        // Test 4: S√©curit√©
        const securityTest = await testSecurityHeaders();
        results.push({ name: 'En-t√™tes de s√©curit√©', passed: securityTest });
        
        // G√©n√©rer le rapport final
        const allPassed = generateReport(results);
        
        process.exit(allPassed ? 0 : 1);
        
    } catch (error) {
        log.error(`Erreur critique: ${error.message}`);
        process.exit(1);
    }
}

// Ex√©cuter si appel√© directement
if (require.main === module) {
    main();
}

module.exports = {
    testLocalStructure,
    testGitHubActions,
    testWebsiteAccess,
    testSecurityHeaders
};